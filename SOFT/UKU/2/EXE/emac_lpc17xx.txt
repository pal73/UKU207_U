; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\EXE\emac_lpc17xx.o --depend=.\EXE\emac_lpc17xx.d --feedback=.\EXE\UKU_220_IPS_TERMOKOMPENSAT.fed --cpu=Cortex-M3 --apcs=interwork -O1 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\NXP\LPC17xx -D__MICROLIB -DUKU_220_IPS_TERMOKOMPENSAT -DUKU2071x -DAPSENERGIA --omf_browse=.\EXE\emac_lpc17xx.crf C:\Keil\ARM\Boards\Keil\MCB1700\RL\TCPnet\Library\EMAC_LPC17xx.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  tx_descr_init PROC
;;;324    
;;;325    static void tx_descr_init (void) {
000000  b530              PUSH     {r4,r5,lr}
;;;326      /* Initialize Transmit Descriptor and Status array. */
;;;327      U32 i;
;;;328    
;;;329      for (i = 0; i < NUM_TX_FRAG; i++) {
000002  2000              MOVS     r0,#0
;;;330        Tx_Desc[i].Packet = (U32)&tx_buf[i];
000004  4cff              LDR      r4,|L1.1028|
000006  2200              MOVS     r2,#0                 ;329
000008  49ff              LDR      r1,|L1.1032|
;;;331        Tx_Desc[i].Ctrl   = 0;
;;;332        Tx_Stat[i].Info   = 0;
00000a  f1010318          ADD      r3,r1,#0x18
                  |L1.14|
00000e  eb000540          ADD      r5,r0,r0,LSL #1       ;330
000012  eb042545          ADD      r5,r4,r5,LSL #9       ;330
000016  f8415030          STR      r5,[r1,r0,LSL #3]     ;330
00001a  eb0105c0          ADD      r5,r1,r0,LSL #3       ;331
00001e  606a              STR      r2,[r5,#4]            ;331
000020  f8432020          STR      r2,[r3,r0,LSL #2]
000024  1c40              ADDS     r0,r0,#1              ;329
000026  2803              CMP      r0,#3                 ;329
000028  d3f1              BCC      |L1.14|
;;;333      }
;;;334    
;;;335      /* Set EMAC Transmit Descriptor Registers. */
;;;336      LPC_EMAC->TxDescriptor       = (U32)&Tx_Desc[0];
00002a  48f8              LDR      r0,|L1.1036|
00002c  6001              STR      r1,[r0,#0]
;;;337      LPC_EMAC->TxStatus           = (U32)&Tx_Stat[0];
00002e  6043              STR      r3,[r0,#4]
;;;338      LPC_EMAC->TxDescriptorNumber = NUM_TX_FRAG-1;
000030  f04f0102          MOV      r1,#2
000034  6081              STR      r1,[r0,#8]
;;;339    
;;;340      /* Tx Descriptors Point to 0 */
;;;341      LPC_EMAC->TxProduceIndex  = 0;
000036  60c2              STR      r2,[r0,#0xc]
;;;342    }
000038  bd30              POP      {r4,r5,pc}
;;;343    
                          ENDP

                  rx_descr_init PROC
;;;301    
;;;302    static void rx_descr_init (void) {
00003a  b570              PUSH     {r4-r6,lr}
;;;303      /* Initialize Receive Descriptor and Status array. */
;;;304      U32 i;
;;;305    
;;;306      for (i = 0; i < NUM_RX_FRAG; i++) {
00003c  2000              MOVS     r0,#0
;;;307        Rx_Desc[i].Packet  = (U32)&rx_buf[i];
00003e  4cf2              LDR      r4,|L1.1032|
000040  2100              MOVS     r1,#0                 ;306
000042  3424              ADDS     r4,r4,#0x24
000044  f1a40364          SUB      r3,r4,#0x64
;;;308        Rx_Desc[i].Ctrl    = RCTRL_INT | (ETH_FRAG_SIZE-1);
000048  4df1              LDR      r5,|L1.1040|
;;;309        Rx_Stat[i].Info    = 0;
00004a  f1030220          ADD      r2,r3,#0x20
                  |L1.78|
00004e  eb000640          ADD      r6,r0,r0,LSL #1       ;307
000052  eb042646          ADD      r6,r4,r6,LSL #9       ;307
000056  f8436030          STR      r6,[r3,r0,LSL #3]     ;307
00005a  eb0306c0          ADD      r6,r3,r0,LSL #3       ;308
00005e  6075              STR      r5,[r6,#4]            ;308
000060  f8421030          STR      r1,[r2,r0,LSL #3]
;;;310        Rx_Stat[i].HashCRC = 0;
000064  eb0206c0          ADD      r6,r2,r0,LSL #3
000068  6071              STR      r1,[r6,#4]
00006a  1c40              ADDS     r0,r0,#1              ;306
00006c  2804              CMP      r0,#4                 ;306
00006e  d3ee              BCC      |L1.78|
;;;311      }
;;;312    
;;;313      /* Set EMAC Receive Descriptor Registers. */
;;;314      LPC_EMAC->RxDescriptor       = (U32)&Rx_Desc[0];
000070  48e8              LDR      r0,|L1.1044|
000072  6003              STR      r3,[r0,#0]
;;;315      LPC_EMAC->RxStatus           = (U32)&Rx_Stat[0];
000074  6042              STR      r2,[r0,#4]
;;;316      LPC_EMAC->RxDescriptorNumber = NUM_RX_FRAG-1;
000076  f04f0203          MOV      r2,#3
00007a  6082              STR      r2,[r0,#8]
;;;317    
;;;318      /* Rx Descriptors Point to 0 */
;;;319      LPC_EMAC->RxConsumeIndex  = 0;
00007c  6101              STR      r1,[r0,#0x10]
;;;320    }
00007e  bd70              POP      {r4-r6,pc}
;;;321    
                          ENDP

                  turnaround_MDIO PROC
;;;367    
;;;368    static void turnaround_MDIO (void) {
000080  48e5              LDR      r0,|L1.1048|
;;;369      /* Turnaround MDO is tristated. */
;;;370    
;;;371      LPC_GPIO2->FIODIR &= ~MDIO;
000082  6c01              LDR      r1,[r0,#0x40]
000084  f4217100          BIC      r1,r1,#0x200
000088  6401              STR      r1,[r0,#0x40]
;;;372      LPC_GPIO2->FIOSET  = MDC;
00008a  1541              ASRS     r1,r0,#21
00008c  6581              STR      r1,[r0,#0x58]
;;;373      delay ();
00008e  bf00              NOP      
000090  bf00              NOP      
000092  bf00              NOP      
;;;374      LPC_GPIO2->FIOCLR  = MDC;
000094  65c1              STR      r1,[r0,#0x5c]
;;;375      delay ();
000096  bf00              NOP      
000098  bf00              NOP      
00009a  bf00              NOP      
;;;376    }
00009c  4770              BX       lr
;;;377    
                          ENDP

                  input_MDIO PROC
;;;379    
;;;380    static U32 input_MDIO (void) {
00009e  b510              PUSH     {r4,lr}
;;;381      /* Input a value from the MII PHY management interface. */
;;;382      U32 i,val = 0;
0000a0  2000              MOVS     r0,#0
;;;383    
;;;384      for (i = 0; i < 16; i++) {
0000a2  2100              MOVS     r1,#0
;;;385        val <<= 1;
;;;386        LPC_GPIO2->FIOSET = MDC;
0000a4  4adc              LDR      r2,|L1.1048|
0000a6  f44f7380          MOV      r3,#0x100
                  |L1.170|
0000aa  0040              LSLS     r0,r0,#1              ;385
0000ac  6593              STR      r3,[r2,#0x58]
;;;387        delay ();
0000ae  bf00              NOP      
0000b0  bf00              NOP      
0000b2  bf00              NOP      
;;;388        LPC_GPIO2->FIOCLR = MDC;
0000b4  65d3              STR      r3,[r2,#0x5c]
;;;389        if (LPC_GPIO2->FIOPIN & MDIO) {
0000b6  6d54              LDR      r4,[r2,#0x54]
0000b8  05a4              LSLS     r4,r4,#22
0000ba  d501              BPL      |L1.192|
;;;390          val |= 1;
0000bc  f0400001          ORR      r0,r0,#1
                  |L1.192|
0000c0  1c49              ADDS     r1,r1,#1              ;384
0000c2  2910              CMP      r1,#0x10              ;384
0000c4  d3f1              BCC      |L1.170|
;;;391        }
;;;392      }
;;;393      return (val);
;;;394    }
0000c6  bd10              POP      {r4,pc}
;;;395    
                          ENDP

                  output_MDIO PROC
;;;348    
;;;349    static void output_MDIO (U32 val, U32 n) {
0000c8  b510              PUSH     {r4,lr}
;;;350      /* Output a value to the MII PHY management interface. */
;;;351    
;;;352      for (val <<= (32 - n); n; val <<= 1, n--) {
0000ca  f1c10220          RSB      r2,r1,#0x20
0000ce  4090              LSLS     r0,r0,r2
;;;353        if (val & 0x80000000) {
;;;354          LPC_GPIO2->FIOSET = MDIO;
0000d0  4ad1              LDR      r2,|L1.1048|
0000d2  f44f7300          MOV      r3,#0x200
;;;355        }
;;;356        else {
;;;357          LPC_GPIO2->FIOCLR = MDIO;
;;;358        }
;;;359        delay ();
;;;360        LPC_GPIO2->FIOSET = MDC;
0000d6  1554              ASRS     r4,r2,#21
0000d8  e00e              B        |L1.248|
                  |L1.218|
0000da  2800              CMP      r0,#0                 ;353
0000dc  da01              BGE      |L1.226|
0000de  6593              STR      r3,[r2,#0x58]         ;354
0000e0  e000              B        |L1.228|
                  |L1.226|
0000e2  65d3              STR      r3,[r2,#0x5c]         ;357
                  |L1.228|
0000e4  bf00              NOP                            ;359
0000e6  bf00              NOP                            ;359
0000e8  bf00              NOP                            ;359
0000ea  6594              STR      r4,[r2,#0x58]
;;;361        delay ();
0000ec  bf00              NOP      
0000ee  bf00              NOP      
0000f0  bf00              NOP      
;;;362        LPC_GPIO2->FIOCLR = MDC;
0000f2  65d4              STR      r4,[r2,#0x5c]
0000f4  0040              LSLS     r0,r0,#1              ;352
0000f6  1e49              SUBS     r1,r1,#1              ;352
                  |L1.248|
0000f8  2900              CMP      r1,#0                 ;352
0000fa  d1ee              BNE      |L1.218|
;;;363      }
;;;364    }
0000fc  bd10              POP      {r4,pc}
;;;365    
                          ENDP

                  read_PHY PROC
;;;445    
;;;446    static U16 read_PHY (U32 PhyReg) {
0000fe  b510              PUSH     {r4,lr}
000100  4604              MOV      r4,r0
;;;447      /* Read a PHY register 'PhyReg'. */
;;;448      U32 tout, val;
;;;449    
;;;450      if (dev_175x == __TRUE) {
000102  48c6              LDR      r0,|L1.1052|
000104  7800              LDRB     r0,[r0,#0]  ; dev_175x
000106  2801              CMP      r0,#1
000108  d013              BEQ      |L1.306|
;;;451        /* Software MII Management for LPC175x. */
;;;452        /* Remapped MDC on P2.8 and MDIO on P2.9 does not work. */
;;;453        LPC_GPIO2->FIODIR |= MDIO;
;;;454    
;;;455        /* 32 consecutive ones on MDO to establish sync */
;;;456        output_MDIO (0xFFFFFFFF, 32);
;;;457    
;;;458        /* start code (01), read command (10) */
;;;459        output_MDIO (0x06, 4);
;;;460    
;;;461        /* write PHY address */
;;;462        output_MDIO (DP83848C_DEF_ADR >> 8, 5);
;;;463    
;;;464        /* write the PHY register to write */
;;;465        output_MDIO (PhyReg, 5);
;;;466    
;;;467        /* turnaround MDO is tristated */
;;;468        turnaround_MDIO ();
;;;469    
;;;470        /* read the data value */
;;;471        val = input_MDIO ();
;;;472    
;;;473        /* turnaround MDIO is tristated */
;;;474        turnaround_MDIO ();
;;;475      }
;;;476      else {
;;;477        LPC_EMAC->MADR = DP83848C_DEF_ADR | PhyReg;
00010a  f04f41a0          MOV      r1,#0x50000000
00010e  f4447080          ORR      r0,r4,#0x100
000112  6288              STR      r0,[r1,#0x28]
;;;478        LPC_EMAC->MCMD = MCMD_READ;
000114  2001              MOVS     r0,#1
000116  6248              STR      r0,[r1,#0x24]
;;;479    
;;;480        /* Wait until operation completed */
;;;481        for (tout = 0; tout < MII_RD_TOUT; tout++) {
000118  2000              MOVS     r0,#0
00011a  130b              ASRS     r3,r1,#12
                  |L1.284|
;;;482          if ((LPC_EMAC->MIND & MIND_BUSY) == 0) {
00011c  6b4a              LDR      r2,[r1,#0x34]
00011e  07d2              LSLS     r2,r2,#31
000120  d002              BEQ      |L1.296|
000122  1c40              ADDS     r0,r0,#1              ;481
000124  4298              CMP      r0,r3                 ;481
000126  d3f9              BCC      |L1.284|
                  |L1.296|
;;;483            break;
;;;484          }
;;;485        }
;;;486        LPC_EMAC->MCMD = 0;
000128  2000              MOVS     r0,#0
00012a  6248              STR      r0,[r1,#0x24]
;;;487        val = LPC_EMAC->MRDD;
00012c  6b0c              LDR      r4,[r1,#0x30]
                  |L1.302|
;;;488      }
;;;489      return (val);
00012e  b2a0              UXTH     r0,r4
;;;490    }
000130  bd10              POP      {r4,pc}
                  |L1.306|
000132  48b9              LDR      r0,|L1.1048|
000134  6c01              LDR      r1,[r0,#0x40]         ;453
000136  f4417100          ORR      r1,r1,#0x200          ;453
00013a  6401              STR      r1,[r0,#0x40]         ;453
00013c  2120              MOVS     r1,#0x20              ;456
00013e  f04f30ff          MOV      r0,#0xffffffff        ;456
000142  f7fffffe          BL       output_MDIO
000146  2104              MOVS     r1,#4                 ;459
000148  2006              MOVS     r0,#6                 ;459
00014a  f7fffffe          BL       output_MDIO
00014e  2105              MOVS     r1,#5                 ;462
000150  2001              MOVS     r0,#1                 ;462
000152  f7fffffe          BL       output_MDIO
000156  2105              MOVS     r1,#5                 ;465
000158  4620              MOV      r0,r4                 ;465
00015a  f7fffffe          BL       output_MDIO
00015e  f7fffffe          BL       turnaround_MDIO
000162  f7fffffe          BL       input_MDIO
000166  4604              MOV      r4,r0                 ;471
000168  f7fffffe          BL       turnaround_MDIO
00016c  e7df              B        |L1.302|
;;;491    
                          ENDP

                  write_PHY PROC
;;;398    
;;;399    static void write_PHY (U32 PhyReg, U16 Value) {
00016e  b570              PUSH     {r4-r6,lr}
000170  4605              MOV      r5,r0
000172  460c              MOV      r4,r1
;;;400      /* Write a data 'Value' to PHY register 'PhyReg'. */
;;;401      U32 tout;
;;;402    
;;;403      if (dev_175x == __TRUE) {
000174  48a9              LDR      r0,|L1.1052|
000176  7800              LDRB     r0,[r0,#0]  ; dev_175x
000178  2801              CMP      r0,#1
00017a  d00e              BEQ      |L1.410|
;;;404        /* Software MII Management for LPC175x. */
;;;405        /* Remapped MDC on P2.8 and MDIO on P2.9 do not work. */
;;;406        LPC_GPIO2->FIODIR |= MDIO;
;;;407    
;;;408        /* 32 consecutive ones on MDO to establish sync */
;;;409        output_MDIO (0xFFFFFFFF, 32);
;;;410    
;;;411        /* start code (01), write command (01) */
;;;412        output_MDIO (0x05, 4);
;;;413    
;;;414        /* write PHY address */
;;;415        output_MDIO (DP83848C_DEF_ADR >> 8, 5);
;;;416    
;;;417        /* write the PHY register to write */
;;;418        output_MDIO (PhyReg, 5);
;;;419    
;;;420        /* turnaround MDIO (1,0)*/
;;;421        output_MDIO (0x02, 2);
;;;422    
;;;423        /* write the data value */
;;;424        output_MDIO (Value, 16);
;;;425    
;;;426        /* turnaround MDO is tristated */
;;;427        turnaround_MDIO ();
;;;428      }
;;;429      else {
;;;430        /* Hardware MII Management for LPC176x devices. */
;;;431        LPC_EMAC->MADR = DP83848C_DEF_ADR | PhyReg;
00017c  f04f42a0          MOV      r2,#0x50000000
000180  f4457080          ORR      r0,r5,#0x100
000184  6290              STR      r0,[r2,#0x28]
;;;432        LPC_EMAC->MWTD = Value;
000186  62d4              STR      r4,[r2,#0x2c]
;;;433    
;;;434        /* Wait utill operation completed */
;;;435        for (tout = 0; tout < MII_WR_TOUT; tout++) {
000188  2000              MOVS     r0,#0
00018a  1313              ASRS     r3,r2,#12
                  |L1.396|
;;;436          if ((LPC_EMAC->MIND & MIND_BUSY) == 0) {
00018c  6b51              LDR      r1,[r2,#0x34]
00018e  07c9              LSLS     r1,r1,#31
000190  d002              BEQ      |L1.408|
000192  1c40              ADDS     r0,r0,#1              ;435
000194  4298              CMP      r0,r3                 ;435
000196  d3f9              BCC      |L1.396|
                  |L1.408|
;;;437            break;
;;;438          }
;;;439        }
;;;440      }
;;;441    }
000198  bd70              POP      {r4-r6,pc}
                  |L1.410|
00019a  489f              LDR      r0,|L1.1048|
00019c  6c01              LDR      r1,[r0,#0x40]         ;406
00019e  f4417100          ORR      r1,r1,#0x200          ;406
0001a2  6401              STR      r1,[r0,#0x40]         ;406
0001a4  2120              MOVS     r1,#0x20              ;409
0001a6  f04f30ff          MOV      r0,#0xffffffff        ;409
0001aa  f7fffffe          BL       output_MDIO
0001ae  2104              MOVS     r1,#4                 ;412
0001b0  2005              MOVS     r0,#5                 ;412
0001b2  f7fffffe          BL       output_MDIO
0001b6  2105              MOVS     r1,#5                 ;415
0001b8  2001              MOVS     r0,#1                 ;415
0001ba  f7fffffe          BL       output_MDIO
0001be  2105              MOVS     r1,#5                 ;418
0001c0  4628              MOV      r0,r5                 ;418
0001c2  f7fffffe          BL       output_MDIO
0001c6  2102              MOVS     r1,#2                 ;421
0001c8  4608              MOV      r0,r1                 ;421
0001ca  f7fffffe          BL       output_MDIO
0001ce  2110              MOVS     r1,#0x10              ;424
0001d0  4620              MOV      r0,r4                 ;424
0001d2  f7fffffe          BL       output_MDIO
0001d6  e8bd4070          POP      {r4-r6,lr}            ;427
0001da  e7fe              B        turnaround_MDIO
;;;442    
                          ENDP

                  init_ethernet PROC
;;;66     
;;;67     void init_ethernet (void) {
0001dc  e92d41fc          PUSH     {r2-r8,lr}
;;;68       /* Initialize the EMAC ethernet controller. */
;;;69       U32 regv,tout,id1,id2;
;;;70       U32 pb[2];
;;;71     
;;;72       dev_175x = __FALSE;
0001e0  4c8e              LDR      r4,|L1.1052|
0001e2  2600              MOVS     r6,#0
0001e4  7026              STRB     r6,[r4,#0]
;;;73       /* Read device ID with IAP*/
;;;74       pb[0] = 54;
0001e6  2036              MOVS     r0,#0x36
0001e8  9000              STR      r0,[sp,#0]
;;;75       iap_entry (&pb[0], &pb[0]);
0001ea  6862              LDR      r2,[r4,#4]  ; iap_entry
0001ec  4669              MOV      r1,sp
0001ee  4668              MOV      r0,sp
0001f0  4790              BLX      r2
;;;76       if ((pb[1] >> 24) == 0x25) {
0001f2  9801              LDR      r0,[sp,#4]
0001f4  2125              MOVS     r1,#0x25
0001f6  ebb16f10          CMP      r1,r0,LSR #24
0001fa  d101              BNE      |L1.512|
;;;77         /* Use software RMII management routines. */
;;;78         dev_175x = __TRUE;
0001fc  2001              MOVS     r0,#1
0001fe  7020              STRB     r0,[r4,#0]
                  |L1.512|
;;;79       }
;;;80     
;;;81       /* Power Up the EMAC controller. */
;;;82       LPC_SC->PCONP |= 0x40000000;
000200  4887              LDR      r0,|L1.1056|
000202  6801              LDR      r1,[r0,#0]
000204  f0414180          ORR      r1,r1,#0x40000000
000208  6001              STR      r1,[r0,#0]
;;;83     
;;;84       /* Enable P1 Ethernet Pins. */
;;;85       LPC_PINCON->PINSEL2 = 0x50150105;
00020a  4887              LDR      r0,|L1.1064|
00020c  4985              LDR      r1,|L1.1060|
00020e  6081              STR      r1,[r0,#8]
;;;86       if (dev_175x == __FALSE) {
000210  7821              LDRB     r1,[r4,#0]  ; dev_175x
000212  b3f1              CBZ      r1,|L1.658|
;;;87         /* LPC176x devices, no MDIO, MDC remap. */
;;;88         LPC_PINCON->PINSEL3 = (LPC_PINCON->PINSEL3 & ~0x0000000F) | 0x00000005;
;;;89       }
;;;90       else {
;;;91         /* LPC175x devices, use software MII management. */  
;;;92         LPC_PINCON->PINSEL4 &= ~0x000F0000;
000214  6901              LDR      r1,[r0,#0x10]
000216  f4212170          BIC      r1,r1,#0xf0000
00021a  6101              STR      r1,[r0,#0x10]
;;;93         LPC_GPIO2->FIODIR |= MDC;
00021c  487e              LDR      r0,|L1.1048|
00021e  6c01              LDR      r1,[r0,#0x40]
000220  f4417180          ORR      r1,r1,#0x100
000224  6401              STR      r1,[r0,#0x40]
                  |L1.550|
;;;94       }
;;;95     
;;;96       /* Reset all EMAC internal modules. */
;;;97       LPC_EMAC->MAC1    = MAC1_RES_TX | MAC1_RES_MCS_TX | MAC1_RES_RX | 
000226  f04f45a0          MOV      r5,#0x50000000
00022a  f44f404f          MOV      r0,#0xcf00
00022e  6028              STR      r0,[r5,#0]
;;;98                           MAC1_RES_MCS_RX | MAC1_SIM_RES | MAC1_SOFT_RES;
;;;99       LPC_EMAC->Command = CR_REG_RES | CR_TX_RES | CR_RX_RES | CR_PASS_RUNT_FRM;
000230  2078              MOVS     r0,#0x78
000232  f8c50100          STR      r0,[r5,#0x100]
;;;100    
;;;101      /* A short delay after reset. */
;;;102      for (tout = 100; tout; tout--);
000236  2064              MOVS     r0,#0x64
                  |L1.568|
000238  1e40              SUBS     r0,r0,#1
00023a  2800              CMP      r0,#0
00023c  d1fc              BNE      |L1.568|
;;;103    
;;;104      /* Initialize MAC control registers. */
;;;105      LPC_EMAC->MAC1 = MAC1_PASS_ALL;
00023e  2002              MOVS     r0,#2
000240  6028              STR      r0,[r5,#0]
;;;106      LPC_EMAC->MAC2 = MAC2_CRC_EN | MAC2_PAD_EN;
000242  2030              MOVS     r0,#0x30
000244  6068              STR      r0,[r5,#4]
;;;107      LPC_EMAC->MAXF = ETH_MAX_FLEN;
000246  0140              LSLS     r0,r0,#5
000248  6168              STR      r0,[r5,#0x14]
;;;108      LPC_EMAC->CLRT = CLRT_DEF;
00024a  f243700f          MOV      r0,#0x370f
00024e  6128              STR      r0,[r5,#0x10]
;;;109      LPC_EMAC->IPGR = IPGR_DEF;
000250  2712              MOVS     r7,#0x12
000252  60ef              STR      r7,[r5,#0xc]
;;;110    
;;;111      /* Enable Reduced MII interface. */
;;;112      LPC_EMAC->Command = CR_RMII | CR_PASS_RUNT_FRM;
000254  0178              LSLS     r0,r7,#5
000256  f8c50100          STR      r0,[r5,#0x100]
;;;113    
;;;114      /* Reset Reduced MII Logic. */
;;;115      LPC_EMAC->SUPP = SUPP_RES_RMII;
00025a  f44f6000          MOV      r0,#0x800
00025e  61a8              STR      r0,[r5,#0x18]
;;;116      for (tout = 100; tout; tout--);
000260  2464              MOVS     r4,#0x64
                  |L1.610|
000262  1e64              SUBS     r4,r4,#1
000264  2c00              CMP      r4,#0
000266  d1fc              BNE      |L1.610|
;;;117      LPC_EMAC->SUPP = 0;
000268  61ae              STR      r6,[r5,#0x18]
;;;118    
;;;119      /* Put the DP83848C in reset mode */
;;;120      write_PHY (PHY_REG_BMCR, 0x8000);
00026a  f44f4100          MOV      r1,#0x8000
00026e  2000              MOVS     r0,#0
000270  f7fffffe          BL       write_PHY
;;;121    
;;;122      /* Wait for hardware reset to end. */
;;;123      for (tout = 0; tout < 0x100000; tout++) {
000274  f44f1880          MOV      r8,#0x100000
                  |L1.632|
;;;124        regv = read_PHY (PHY_REG_BMCR);
000278  2000              MOVS     r0,#0
00027a  f7fffffe          BL       read_PHY
;;;125        if (!(regv & 0x8800)) {
00027e  f4104f08          TST      r0,#0x8800
000282  d002              BEQ      |L1.650|
000284  1c64              ADDS     r4,r4,#1              ;123
000286  4544              CMP      r4,r8                 ;123
000288  d3f6              BCC      |L1.632|
                  |L1.650|
;;;126          /* Reset complete, device not Power Down. */
;;;127          break;
;;;128        }
;;;129      }
;;;130    
;;;131      /* Check if this is a DP83848C PHY. */
;;;132      id1 = read_PHY (PHY_REG_IDR1);
00028a  2002              MOVS     r0,#2
00028c  f7fffffe          BL       read_PHY
000290  e000              B        |L1.660|
                  |L1.658|
000292  e022              B        |L1.730|
                  |L1.660|
000294  4604              MOV      r4,r0
;;;133      id2 = read_PHY (PHY_REG_IDR2);
000296  2003              MOVS     r0,#3
000298  f7fffffe          BL       read_PHY
;;;134    
;;;135      if (((id1 << 16) | (id2 & 0xFFF0)) == DP83848C_ID) {
00029c  f64f71f0          MOV      r1,#0xfff0
0002a0  4008              ANDS     r0,r0,r1
0002a2  4962              LDR      r1,|L1.1068|
0002a4  ea404004          ORR      r0,r0,r4,LSL #16
0002a8  4288              CMP      r0,r1
0002aa  d10d              BNE      |L1.712|
;;;136        /* Configure the PHY device */
;;;137    #if defined (_10MBIT_)
;;;138        /* Connect at 10MBit */
;;;139        write_PHY (PHY_REG_BMCR, PHY_FULLD_10M);
;;;140    #elif defined (_100MBIT_)
;;;141        /* Connect at 100MBit */
;;;142        write_PHY (PHY_REG_BMCR, PHY_FULLD_100M);
;;;143    #else
;;;144        /* Use autonegotiation about the link speed. */
;;;145        write_PHY (PHY_REG_BMCR, PHY_AUTO_NEG);
0002ac  f44f5140          MOV      r1,#0x3000
0002b0  2000              MOVS     r0,#0
0002b2  f7fffffe          BL       write_PHY
;;;146        /* Wait to complete Auto_Negotiation. */
;;;147        for (tout = 0; tout < 0x100000; tout++) {
0002b6  2400              MOVS     r4,#0
                  |L1.696|
;;;148          regv = read_PHY (PHY_REG_BMSR);
0002b8  2001              MOVS     r0,#1
0002ba  f7fffffe          BL       read_PHY
;;;149          if (regv & 0x0020) {
0002be  0680              LSLS     r0,r0,#26
0002c0  d402              BMI      |L1.712|
0002c2  1c64              ADDS     r4,r4,#1              ;147
0002c4  4544              CMP      r4,r8                 ;147
0002c6  d3f7              BCC      |L1.696|
                  |L1.712|
;;;150            /* Autonegotiation Complete. */
;;;151            break;
;;;152          }
;;;153        }
;;;154    #endif
;;;155      }
;;;156    
;;;157      /* Check the link status. */
;;;158      for (tout = 0; tout < 0x10000; tout++) {
0002c8  2400              MOVS     r4,#0
0002ca  f44f3880          MOV      r8,#0x10000
                  |L1.718|
;;;159        regv = read_PHY (PHY_REG_STS);
0002ce  2010              MOVS     r0,#0x10
0002d0  f7fffffe          BL       read_PHY
;;;160        if (regv & 0x0001) {
0002d4  07c1              LSLS     r1,r0,#31
0002d6  d109              BNE      |L1.748|
0002d8  e005              B        |L1.742|
                  |L1.730|
0002da  68c1              LDR      r1,[r0,#0xc]          ;88
0002dc  f021010f          BIC      r1,r1,#0xf            ;88
0002e0  1d49              ADDS     r1,r1,#5              ;88
0002e2  60c1              STR      r1,[r0,#0xc]          ;88
0002e4  e79f              B        |L1.550|
                  |L1.742|
0002e6  1c64              ADDS     r4,r4,#1              ;158
0002e8  4544              CMP      r4,r8                 ;158
0002ea  d3f0              BCC      |L1.718|
                  |L1.748|
;;;161          /* Link is on. */
;;;162          break;
;;;163        }
;;;164      }
;;;165    
;;;166      /* Configure Full/Half Duplex mode. */
;;;167      if (regv & 0x0004) {
0002ec  0741              LSLS     r1,r0,#29
0002ee  d50c              BPL      |L1.778|
;;;168        /* Full duplex is enabled. */
;;;169        LPC_EMAC->MAC2    |= MAC2_FULL_DUP;
0002f0  6869              LDR      r1,[r5,#4]
0002f2  f0410101          ORR      r1,r1,#1
0002f6  6069              STR      r1,[r5,#4]
;;;170        LPC_EMAC->Command |= CR_FULL_DUP;
0002f8  f8d51100          LDR      r1,[r5,#0x100]
0002fc  f4416180          ORR      r1,r1,#0x400
000300  f8c51100          STR      r1,[r5,#0x100]
;;;171        LPC_EMAC->IPGT     = IPGT_FULL_DUP;
000304  2115              MOVS     r1,#0x15
000306  60a9              STR      r1,[r5,#8]
000308  e000              B        |L1.780|
                  |L1.778|
;;;172      }
;;;173      else {
;;;174        /* Half duplex mode. */
;;;175        LPC_EMAC->IPGT = IPGT_HALF_DUP;
00030a  60af              STR      r7,[r5,#8]
                  |L1.780|
;;;176      }
;;;177    
;;;178      /* Configure 100MBit/10MBit mode. */
;;;179      if (regv & 0x0002) {
00030c  0780              LSLS     r0,r0,#30
00030e  d501              BPL      |L1.788|
;;;180        /* 10MBit mode. */
;;;181        LPC_EMAC->SUPP = 0;
000310  61ae              STR      r6,[r5,#0x18]
000312  e002              B        |L1.794|
                  |L1.788|
;;;182      }
;;;183      else {
;;;184        /* 100MBit mode. */
;;;185        LPC_EMAC->SUPP = SUPP_SPEED;
000314  f44f7080          MOV      r0,#0x100
000318  61a8              STR      r0,[r5,#0x18]
                  |L1.794|
;;;186      }
;;;187    
;;;188      /* Set the Ethernet MAC Address registers */
;;;189      LPC_EMAC->SA0 = ((U32)own_hw_adr[5] << 8) | (U32)own_hw_adr[4];
00031a  4845              LDR      r0,|L1.1072|
00031c  7901              LDRB     r1,[r0,#4]  ; own_hw_adr
00031e  7942              LDRB     r2,[r0,#5]  ; own_hw_adr
000320  ea412102          ORR      r1,r1,r2,LSL #8
000324  6429              STR      r1,[r5,#0x40]
;;;190      LPC_EMAC->SA1 = ((U32)own_hw_adr[3] << 8) | (U32)own_hw_adr[2];
000326  7881              LDRB     r1,[r0,#2]  ; own_hw_adr
000328  78c2              LDRB     r2,[r0,#3]  ; own_hw_adr
00032a  ea412102          ORR      r1,r1,r2,LSL #8
00032e  6469              STR      r1,[r5,#0x44]
;;;191      LPC_EMAC->SA2 = ((U32)own_hw_adr[1] << 8) | (U32)own_hw_adr[0];
000330  7801              LDRB     r1,[r0,#0]  ; own_hw_adr
000332  7840              LDRB     r0,[r0,#1]  ; own_hw_adr
000334  ea412000          ORR      r0,r1,r0,LSL #8
000338  64a8              STR      r0,[r5,#0x48]
;;;192    
;;;193      /* Initialize Tx and Rx DMA Descriptors */
;;;194      rx_descr_init ();
00033a  f7fffffe          BL       rx_descr_init
;;;195      tx_descr_init ();
00033e  f7fffffe          BL       tx_descr_init
;;;196    
;;;197      /* Receive Broadcast, Multicast and Perfect Match Packets */
;;;198      LPC_EMAC->RxFilterCtrl = RFC_MCAST_EN | RFC_BCAST_EN | RFC_PERFECT_EN;
000342  2026              MOVS     r0,#0x26
000344  f8c50200          STR      r0,[r5,#0x200]
;;;199    
;;;200      /* Enable EMAC interrupts. */
;;;201      LPC_EMAC->IntEnable = INT_RX_DONE | INT_TX_DONE;
000348  2088              MOVS     r0,#0x88
00034a  f8c50fe4          STR      r0,[r5,#0xfe4]
;;;202    
;;;203      /* Reset all interrupts */
;;;204      LPC_EMAC->IntClear  = 0xFFFF;
00034e  f64f70ff          MOV      r0,#0xffff
000352  f8c50fe8          STR      r0,[r5,#0xfe8]
;;;205    
;;;206      /* Enable receive and transmit mode of MAC Ethernet core */
;;;207      LPC_EMAC->Command  |= (CR_RX_EN | CR_TX_EN);
000356  f8d50100          LDR      r0,[r5,#0x100]
00035a  f0400003          ORR      r0,r0,#3
00035e  f8c50100          STR      r0,[r5,#0x100]
;;;208      LPC_EMAC->MAC1     |= MAC1_REC_EN;
000362  6828              LDR      r0,[r5,#0]
000364  f0400001          ORR      r0,r0,#1
000368  6028              STR      r0,[r5,#0]
;;;209    
;;;210    }
00036a  e8bd81fc          POP      {r2-r8,pc}
;;;211    
                          ENDP

                  int_enable_eth PROC
;;;214    
;;;215    void int_enable_eth (void) {
00036e  4831              LDR      r0,|L1.1076|
000370  f04f5180          MOV      r1,#0x10000000
000374  6001              STR      r1,[r0,#0]
;;;216      /* Ethernet Interrupt Enable function. */
;;;217      NVIC_EnableIRQ(ENET_IRQn);
;;;218    }
000376  4770              BX       lr
;;;219    
                          ENDP

                  int_disable_eth PROC
;;;222    
;;;223    void int_disable_eth (void) {
000378  482f              LDR      r0,|L1.1080|
00037a  f04f5180          MOV      r1,#0x10000000
00037e  6001              STR      r1,[r0,#0]
;;;224      /* Ethernet Interrupt Disable function. */
;;;225      NVIC_DisableIRQ(ENET_IRQn);
;;;226    }
000380  4770              BX       lr
;;;227    
                          ENDP

                  send_frame PROC
;;;230    
;;;231    void send_frame (OS_FRAME *frame) {
000382  b5f0              PUSH     {r4-r7,lr}
;;;232      /* Send frame to EMAC ethernet controller */
;;;233      U32 idx,len;
;;;234      U32 *sp,*dp;
;;;235    
;;;236      idx = LPC_EMAC->TxProduceIndex;
000384  f04f45a0          MOV      r5,#0x50000000
000388  f8d54128          LDR      r4,[r5,#0x128]
;;;237      sp  = (U32 *)&frame->data[0];
00038c  1d02              ADDS     r2,r0,#4
;;;238      dp  = (U32 *)Tx_Desc[idx].Packet;
00038e  4e1e              LDR      r6,|L1.1032|
000390  f8563034          LDR      r3,[r6,r4,LSL #3]
;;;239    
;;;240      /* Copy frame data to EMAC packet buffers. */
;;;241      for (len = (frame->length + 3) >> 2; len; len--) {
000394  8801              LDRH     r1,[r0,#0]
000396  1cc9              ADDS     r1,r1,#3
000398  0889              LSRS     r1,r1,#2
00039a  b121              CBZ      r1,|L1.934|
                  |L1.924|
;;;242        *dp++ = *sp++;
00039c  ca80              LDM      r2!,{r7}
00039e  c380              STM      r3!,{r7}
0003a0  1e49              SUBS     r1,r1,#1              ;241
0003a2  2900              CMP      r1,#0                 ;241
0003a4  d1fa              BNE      |L1.924|
                  |L1.934|
;;;243      }
;;;244      Tx_Desc[idx].Ctrl = (frame->length-1) | (TCTRL_INT | TCTRL_LAST);
0003a6  8800              LDRH     r0,[r0,#0]
0003a8  eb0601c4          ADD      r1,r6,r4,LSL #3
0003ac  1e40              SUBS     r0,r0,#1
0003ae  f0404040          ORR      r0,r0,#0xc0000000
0003b2  6048              STR      r0,[r1,#4]
;;;245    
;;;246      /* Start frame transmission. */
;;;247      if (++idx == NUM_TX_FRAG) idx = 0;
0003b4  1c64              ADDS     r4,r4,#1
0003b6  2c03              CMP      r4,#3
0003b8  d100              BNE      |L1.956|
0003ba  2400              MOVS     r4,#0
                  |L1.956|
;;;248      LPC_EMAC->TxProduceIndex = idx;
0003bc  f8c54128          STR      r4,[r5,#0x128]
;;;249    }
0003c0  bdf0              POP      {r4-r7,pc}
;;;250    
                          ENDP

                  ENET_IRQHandler PROC
;;;253    
;;;254    void ENET_IRQHandler (void) {
0003c2  b570              PUSH     {r4-r6,lr}
;;;255      /* EMAC Ethernet Controller Interrupt function. */
;;;256      OS_FRAME *frame;
;;;257      U32 idx,int_stat,RxLen,info;
;;;258      U32 *sp,*dp;
;;;259    
;;;260      while ((int_stat = (LPC_EMAC->IntStatus & LPC_EMAC->IntEnable)) != 0) {
;;;261        LPC_EMAC->IntClear = int_stat;
0003c4  f04f46a0          MOV      r6,#0x50000000
0003c8  e052              B        |L1.1136|
                  |L1.970|
0003ca  f8c60fe8          STR      r0,[r6,#0xfe8]
;;;262        if (int_stat & INT_RX_DONE) {
0003ce  0700              LSLS     r0,r0,#28
0003d0  d54e              BPL      |L1.1136|
;;;263          /* Packet received, check if packet is valid. */
;;;264          idx = LPC_EMAC->RxConsumeIndex;
0003d2  f8d64118          LDR      r4,[r6,#0x118]
;;;265          while (idx != LPC_EMAC->RxProduceIndex) {
0003d6  e047              B        |L1.1128|
                  |L1.984|
;;;266            info = Rx_Stat[idx].Info;
0003d8  480b              LDR      r0,|L1.1032|
0003da  3820              SUBS     r0,r0,#0x20
0003dc  f8500034          LDR      r0,[r0,r4,LSL #3]
;;;267            if (!(info & RINFO_LAST_FLAG)) {
0003e0  0041              LSLS     r1,r0,#1
0003e2  d53b              BPL      |L1.1116|
;;;268              goto rel;
;;;269            }
;;;270    
;;;271            RxLen = (info & RINFO_SIZE) - 3;
0003e4  f3c0050a          UBFX     r5,r0,#0,#11
0003e8  1eed              SUBS     r5,r5,#3
;;;272            if (RxLen > ETH_MTU || (info & RINFO_ERR_MASK)) {
0003ea  f24051ea          MOV      r1,#0x5ea
0003ee  428d              CMP      r5,r1
0003f0  d834              BHI      |L1.1116|
0003f2  4912              LDR      r1,|L1.1084|
0003f4  4208              TST      r0,r1
0003f6  d131              BNE      |L1.1116|
;;;273              /* Invalid frame, ignore it and free buffer. */
;;;274              goto rel;
;;;275            }
;;;276            /* Flag 0x80000000 to skip sys_error() call when out of memory. */
;;;277            frame = alloc_mem (RxLen | 0x80000000);
0003f8  f0454000          ORR      r0,r5,#0x80000000
0003fc  f7fffffe          BL       alloc_mem
;;;278            /* if 'alloc_mem()' has failed, ignore this packet. */
;;;279            if (frame != NULL) {
000400  b360              CBZ      r0,|L1.1116|
;;;280              dp = (U32 *)&frame->data[0];
000402  e01d              B        |L1.1088|
                  |L1.1028|
                          DCD      ||.bss||+0x1864
                  |L1.1032|
                          DCD      ||.bss||+0x40
                  |L1.1036|
                          DCD      0x5000011c
                  |L1.1040|
                          DCD      0x800005ff
                  |L1.1044|
                          DCD      0x50000108
                  |L1.1048|
                          DCD      0x2009c000
                  |L1.1052|
                          DCD      ||.data||
                  |L1.1056|
                          DCD      0x400fc0c4
                  |L1.1060|
                          DCD      0x50150105
                  |L1.1064|
                          DCD      0x4002c000
                  |L1.1068|
                          DCD      0x20005c90
                  |L1.1072|
                          DCD      own_hw_adr
                  |L1.1076|
                          DCD      0xe000e100
                  |L1.1080|
                          DCD      0xe000e180
                  |L1.1084|
                          DCD      0x1b900000
                  |L1.1088|
000440  1d02              ADDS     r2,r0,#4
;;;281              sp = (U32 *)Rx_Desc[idx].Packet;
000442  490f              LDR      r1,|L1.1152|
000444  f8513034          LDR      r3,[r1,r4,LSL #3]
;;;282              for (RxLen = (RxLen + 3) >> 2; RxLen; RxLen--) {
000448  1ced              ADDS     r5,r5,#3
00044a  08a9              LSRS     r1,r5,#2
00044c  b121              CBZ      r1,|L1.1112|
                  |L1.1102|
;;;283                *dp++ = *sp++;
00044e  cb20              LDM      r3!,{r5}
000450  c220              STM      r2!,{r5}
000452  1e49              SUBS     r1,r1,#1              ;282
000454  2900              CMP      r1,#0                 ;282
000456  d1fa              BNE      |L1.1102|
                  |L1.1112|
;;;284              }
;;;285              put_in_queue (frame);
000458  f7fffffe          BL       put_in_queue
                  |L1.1116|
;;;286            }
;;;287    rel:    if (++idx == NUM_RX_FRAG) idx = 0;
00045c  1c64              ADDS     r4,r4,#1
00045e  2c04              CMP      r4,#4
000460  d100              BNE      |L1.1124|
000462  2400              MOVS     r4,#0
                  |L1.1124|
;;;288            /* Release frame from EMAC buffer. */
;;;289            LPC_EMAC->RxConsumeIndex = idx;
000464  f8c64118          STR      r4,[r6,#0x118]
                  |L1.1128|
000468  f8d60114          LDR      r0,[r6,#0x114]        ;265
00046c  42a0              CMP      r0,r4                 ;265
00046e  d1b3              BNE      |L1.984|
                  |L1.1136|
000470  f8d60fe0          LDR      r0,[r6,#0xfe0]        ;260
000474  f8d61fe4          LDR      r1,[r6,#0xfe4]        ;260
000478  4008              ANDS     r0,r0,r1              ;260
00047a  d1a6              BNE      |L1.970|
;;;290          }
;;;291        }
;;;292        if (int_stat & INT_TX_DONE) {
;;;293          /* Frame transmit completed. */
;;;294        }
;;;295      }
;;;296    
;;;297    }
00047c  bd70              POP      {r4-r6,pc}
;;;298    
                          ENDP

00047e  0000              DCW      0x0000
                  |L1.1152|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  Rx_Desc
                          %        32
                  Rx_Stat
                          %        32
                  Tx_Desc
                          %        24
                  Tx_Stat
                          %        12
                  rx_buf
                          %        6144
                  tx_buf
                          %        4608

                          AREA ||.data||, DATA, ALIGN=2

                  dev_175x
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  iap_entry
                          DCD      0x1fff1ff1
